#!/usr/bin/env python3
"""
Specialized script to regenerate Returns documentation for CMS tools only.
This script processes all .py files in webarena_tools_toRyan/cms/ and updates their documentation
with concise Returns descriptions generated by Claude 3.7.
"""

import os
import json
import sys
from pathlib import Path

# Add the main directory to the path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from main.validation_and_refinement_main import (
    extract_json_key_hierarchy,
    call_claude_for_doc_explanation,
    update_function_docstring_with_returns,
    extract_function_names,
    get_api_description
)

def find_response_file(tool_name, apidocs_dir="extractor/apidocs/"):
    """
    Find the corresponding response JSON file for a tool.
    
    Args:
        tool_name: Name of the tool file (without .py extension)
        apidocs_dir: Directory containing API docs
    
    Returns:
        str: Path to response file if found, None otherwise
    """
    response_filename = f"{tool_name}_response.json"
    
    # Search in all subdirectories of apidocs
    for root, dirs, files in os.walk(apidocs_dir):
        if response_filename in files:
            return os.path.join(root, response_filename)
    
    return None

def load_response_data(response_file_path):
    """
    Load and parse response data from JSON file.
    
    Args:
        response_file_path: Path to the response JSON file
    
    Returns:
        dict: Parsed response data, or None if failed
    """
    try:
        with open(response_file_path, 'r', encoding='utf-8') as f:
            response_data = json.load(f)
        
        print(f"  üîç DEBUG: Raw response data keys: {list(response_data.keys())}")
        
        # The response file contains the tool's stdout structure:
        # {"status_code": 200, "text": "...", "json": {...}, "content": "..."}
        # We need to extract the actual API response from the nested structure
        
        tool_output = response_data.get("json")  # This is the parsed stdout from the tool
        if tool_output is None:
            print(f"  üîç DEBUG: response_data['json'] is None, trying text field")
            # Try to parse the text field as JSON
            text_content = response_data.get("text", "")
            if text_content:
                print(f"  üîç DEBUG: Found text content, length: {len(text_content)}")
                print(f"  üîç DEBUG: Text content preview: {text_content[:200]}...")
                try:
                    tool_output = json.loads(text_content)
                    print(f"  üîç DEBUG: Successfully parsed text as JSON")
                except Exception as e:
                    print(f"  üîç DEBUG: Failed to parse text as JSON: {str(e)}")
                    return None
            else:
                print(f"  üîç DEBUG: No text content available")
                return None
        
        print(f"  üîç DEBUG: Tool output structure:")
        if isinstance(tool_output, dict):
            print(f"  üîç DEBUG: Tool output keys: {list(tool_output.keys())}")
        
        # Now extract the actual API response data from the tool output
        # The tool output has structure: {"status_code": 200, "text": "...", "json": {...}, "content": "..."}
        # We want the "json" field which contains the actual API response
        data_to_analyze = tool_output.get("json")
        if data_to_analyze is None:
            print(f"  üîç DEBUG: tool_output['json'] is None, trying text field")
            # Try to parse the text field as JSON
            text_content = tool_output.get("text", "")
            if text_content:
                print(f"  üîç DEBUG: Found text content in tool output, length: {len(text_content)}")
                try:
                    data_to_analyze = json.loads(text_content)
                    print(f"  üîç DEBUG: Successfully parsed tool output text as JSON")
                    print(f"  üîç DEBUG: Parsed API response keys: {list(data_to_analyze.keys()) if isinstance(data_to_analyze, dict) else 'Not a dict'}")
                except Exception as e:
                    print(f"  üîç DEBUG: Failed to parse tool output text as JSON: {str(e)}")
                    data_to_analyze = tool_output  # Use the whole tool output as fallback
                    print(f"  üîç DEBUG: Using whole tool output as fallback")
            else:
                data_to_analyze = tool_output
                print(f"  üîç DEBUG: No text content in tool output, using whole tool output")
        else:
            print(f"  üîç DEBUG: Found tool_output['json'] - this is the actual API response!")
            print(f"  üîç DEBUG: API response data keys: {list(data_to_analyze.keys()) if isinstance(data_to_analyze, dict) else 'Not a dict'}")
        
        print(f"  üîç DEBUG: Final data_to_analyze type: {type(data_to_analyze)}")
        if isinstance(data_to_analyze, dict):
            print(f"  üîç DEBUG: Final data_to_analyze keys: {list(data_to_analyze.keys())}")
        
        return data_to_analyze
    
    except Exception as e:
        print(f"Error loading response data from {response_file_path}: {str(e)}")
        return None

def regenerate_returns_for_tool(tool_path, response_data):
    """
    Regenerate Returns documentation for a single tool.
    
    Args:
        tool_path: Path to the tool .py file
        response_data: Parsed response data
    
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        # Read the tool code
        with open(tool_path, 'r', encoding='utf-8') as f:
            code = f.read()
        
        print(f"  üîç DEBUG: About to extract key hierarchy from data type: {type(response_data)}")
        if isinstance(response_data, dict):
            print(f"  üîç DEBUG: Response data keys before hierarchy extraction: {list(response_data.keys())}")
        
        # Extract key hierarchy from response data
        key_hierarchy = extract_json_key_hierarchy(response_data)
        
        print(f"  üîç DEBUG: Extracted key hierarchy:")
        print(f"  üîç DEBUG: {json.dumps(key_hierarchy, indent=4)}")
        
        # Get function name
        function_name = extract_function_names(code)
        
        print(f"  üîç DEBUG: Target function name (last): {function_name}")
        
        # For these tools, we'll create a simple API description based on the function name
        api_description = f"API function for {function_name.replace('_', ' ')}"
        
        print(f"  üîç DEBUG: API description: {api_description}")
        print(f"  üîç DEBUG: About to call Claude with the above key hierarchy...")
        
        # Call Claude 3.7 to explain the expected information
        returns_description = call_claude_for_doc_explanation(
            key_hierarchy, function_name, api_description, code
        )
        
        print(f"  üîç DEBUG: Claude returned: {returns_description}")
        
        # Update function documentation with Returns section
        print(f"  üîç DEBUG: About to update function documentation...")
        print(f"  üîç DEBUG: Tool path: {tool_path}")
        print(f"  üîç DEBUG: Returns description: {returns_description}")
        
        success = update_function_docstring_with_returns(tool_path, returns_description)
        
        print(f"  üîç DEBUG: update_function_docstring_with_returns returned: {success}")
        
        # Read the file again to check if it was actually updated
        with open(tool_path, 'r', encoding='utf-8') as f:
            updated_code = f.read()
        
        if returns_description in updated_code:
            print(f"  üîç DEBUG: ‚úÖ Returns description found in updated file!")
        else:
            print(f"  üîç DEBUG: ‚ùå Returns description NOT found in updated file!")
            
        if updated_code != code:
            print(f"  üîç DEBUG: ‚úÖ File content changed")
        else:
            print(f"  üîç DEBUG: ‚ùå File content unchanged")
        
        if success:
            print(f"‚úì Updated: {os.path.basename(tool_path)} -> {returns_description}")
        else:
            print(f"‚úó Failed to update: {os.path.basename(tool_path)}")
        
        return success
    
    except Exception as e:
        print(f"‚úó Error processing {tool_path}: {str(e)}")
        import traceback
        print(f"  üîç DEBUG: Full traceback:")
        traceback.print_exc()
        return False

def main():
    """Main function to regenerate Returns documentation for CMS tools only."""
    print("Regenerating Returns Documentation for CMS Tools")
    print("=" * 60)
    
    tools_dir = "webarena_tools_toRyan/cms"
    apidocs_dir = "extractor/apidocs"
    
    if not os.path.exists(tools_dir):
        print(f"Error: Directory {tools_dir} not found!")
        return
    
    # Find all Python files in the CMS directory
    tool_files = []
    for file in os.listdir(tools_dir):
        if file.endswith('.py'):
            tool_files.append(file)
    
    if not tool_files:
        print(f"No Python files found in {tools_dir}")
        return
    
    print(f"Found {len(tool_files)} CMS tool files to process")
    print(f"Looking for response files in {apidocs_dir}")
    print("-" * 60)
    
    success_count = 0
    error_count = 0
    missing_response_count = 0
    
    for tool_file in sorted(tool_files):
        tool_name = tool_file[:-3]  # Remove .py extension
        tool_path = os.path.join(tools_dir, tool_file)
        
        print(f"\nProcessing: {tool_file}")
        
        # Find corresponding response file
        response_file_path = find_response_file(tool_name, apidocs_dir)
        
        if not response_file_path:
            print(f"  ‚ö†Ô∏è  No response file found for {tool_name}")
            missing_response_count += 1
            continue
        
        print(f"  üìÅ Found response: {response_file_path}")
        
        # Load response data
        response_data = load_response_data(response_file_path)
        
        if response_data is None:
            print(f"  ‚úó Failed to load response data")
            error_count += 1
            continue
        
        # Regenerate Returns documentation
        if regenerate_returns_for_tool(tool_path, response_data):
            success_count += 1
        else:
            error_count += 1
    
    # Summary
    print("\n" + "=" * 60)
    print("CMS TOOLS SUMMARY")
    print("=" * 60)
    total_processed = len(tool_files)
    print(f"Total CMS tools processed: {total_processed}")
    print(f"‚úÖ Successfully updated: {success_count}")
    print(f"‚ö†Ô∏è  Missing response files: {missing_response_count}")
    print(f"‚ùå Errors: {error_count}")
    
    if success_count > 0:
        print(f"\nüéâ Successfully regenerated Returns documentation for {success_count} CMS tools!")
        print("üìù All CMS tools now have concise, Claude-generated Returns descriptions.")
    
    if missing_response_count > 0:
        print(f"\n‚ö†Ô∏è  {missing_response_count} CMS tools are missing response files.")
        print("   These tools may need to be re-validated to generate response data.")
    
    if error_count > 0:
        print(f"\n‚ùå {error_count} CMS tools encountered errors during processing.")
        print("   Check the error messages above for details.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nScript interrupted by user.")
    except Exception as e:
        print(f"\nUnexpected error: {str(e)}")
        import traceback
        traceback.print_exc()
        print("Please check your environment and try again.") 